{"version":3,"sources":["../src/Btc.js"],"names":["addressFormatMap","legacy","p2sh","bech32","MAX_SCRIPT_BLOCK","DEFAULT_VERSION","DEFAULT_LOCKTIME","DEFAULT_SEQUENCE","SIGHASH_ALL","OP_DUP","OP_HASH160","HASH_SIZE","OP_EQUALVERIFY","OP_CHECKSIG","Btc","transport","scrambleKey","decorateAppAPIMethods","buffer","update","digest","path","options","verify","format","Error","paths","p1","p2","Buffer","alloc","length","forEach","element","index","writeUInt32BE","send","then","publicKeyLength","response","addressLength","publicKey","slice","toString","bitcoinAddress","chainCode","opts","arguments","console","warn","getWalletPublicKey_private","transactionData","indexLookup","data","firstRound","prefix","concat","trustedInput","transaction","additionals","inputs","outputs","locktime","isDecred","includes","processScriptBlocks","script","sequence","scriptBlocks","offset","blockSize","push","getTrustedInputRaw","scriptBlock","processWholeScriptBlock","processInputs","treeField","input","tree","from","prevout","createVarint","processOutputs","output","amount","finalData","version","timestamp","sha","serializeTransaction","hash","writeUInt32LE","newTransaction","bip143","overwinter","nVersionGroupId","startUntrustedHashTransactionInputRaw","i","value","outputScript","lockTime","sigHashType","expiryHeight","pathsBuffer","lockTimeBuffer","result","messageHex","message","toSend","maxChunkSize","chunkSize","writeUInt16BE","copy","v","r","s","associatedKeysets","changePath","outputScriptHex","segwit","initialTimestamp","hasTimestamp","undefined","startTime","Date","now","sapling","useBip143","nullScript","nullPrevout","defaultVersion","trustedInputs","regularOutputs","signatures","publicKeys","firstRun","resuming","targetTransaction","getTrustedInputCall","getTrustedInputBIP143","bind","getTrustedInput","nExpiryHeight","extraData","compressPublicKey","Math","floor","startUntrustedHashTransactionInput","provideOutputFullChangePath","hashOutputFull","signTransaction","hashPublicKey","pseudoTX","Object","assign","pseudoTrustedInputs","signature","witness","signatureSize","keySize","tmpScriptData","decredWitness","inputIndex","transactionVersion","prefixBuffer","transactionHex","isSegwitSupported","hasExtraData","equals","varint","getVarint","numberInputs","numberOutputs","witnessScript","outputBuffer","skipWitness","inputBuffer","useWitness","serializeTransactionOutputs","log"],"mappings":"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","file":"Btc.js","sourcesContent":["//@flow\n\n// TODO future refactoring\n// - drop utils.js & refactoring with async/await style\n// - try to avoid every place we do hex<>Buffer conversion. also accept Buffer as func parameters (could accept both a string or a Buffer in the API)\n// - there are redundant code across apps (see Eth vs Btc). we might want to factorize it somewhere. also each app apdu call should be abstracted it out as an api\nimport { foreach, doIf, asyncWhile, splitPath, eachSeries } from \"./utils\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport createHash from \"create-hash\";\n\n/**\n * address format is one of legacy | p2sh | bech32\n */\nexport type AddressFormat = \"legacy\" | \"p2sh\" | \"bech32\";\n\nconst addressFormatMap = {\n  legacy: 0,\n  p2sh: 1,\n  bech32: 2\n};\n\nconst MAX_SCRIPT_BLOCK = 50;\nconst DEFAULT_VERSION = 1;\nconst DEFAULT_LOCKTIME = 0;\nconst DEFAULT_SEQUENCE = 0xffffffff;\nconst SIGHASH_ALL = 1;\nconst OP_DUP = 0x76;\nconst OP_HASH160 = 0xa9;\nconst HASH_SIZE = 0x14;\nconst OP_EQUALVERIFY = 0x88;\nconst OP_CHECKSIG = 0xac;\n/**\n * Bitcoin API.\n *\n * @example\n * import Btc from \"@ledgerhq/hw-app-btc\";\n * const btc = new Btc(transport)\n */\nexport default class Btc {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"BTC\") {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getWalletPublicKey\",\n        \"signP2SHTransaction\",\n        \"signMessageNew\",\n        \"createPaymentTransactionNew\"\n      ],\n      scrambleKey\n    );\n  }\n\n  hashPublicKey(buffer: Buffer) {\n    return createHash(\"rmd160\")\n      .update(\n        createHash(\"sha256\")\n          .update(buffer)\n          .digest()\n      )\n      .digest();\n  }\n\n  getWalletPublicKey_private(\n    path: string,\n    options: {\n      verify?: boolean,\n      format?: AddressFormat\n    } = {}\n  ): Promise<{\n    publicKey: string,\n    bitcoinAddress: string,\n    chainCode: string\n  }> {\n    const { verify, format } = {\n      verify: false,\n      format: \"legacy\",\n      ...options\n    };\n    if (!(format in addressFormatMap)) {\n      throw new Error(\"btc.getWalletPublicKey invalid format=\" + format);\n    }\n    const paths = splitPath(path);\n    var p1 = verify ? 1 : 0;\n    var p2 = addressFormatMap[format];\n    const buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xe0, 0x40, p1, p2, buffer).then(response => {\n      const publicKeyLength = response[0];\n      const addressLength = response[1 + publicKeyLength];\n      const publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n      const bitcoinAddress = response\n        .slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength)\n        .toString(\"ascii\");\n      const chainCode = response\n        .slice(\n          1 + publicKeyLength + 1 + addressLength,\n          1 + publicKeyLength + 1 + addressLength + 32\n        )\n        .toString(\"hex\");\n      return { publicKey, bitcoinAddress, chainCode };\n    });\n  }\n\n  /**\n   * @param path a BIP 32 path\n   * @param options an object with optional these fields:\n   *\n   * - verify (boolean) will ask user to confirm the address on the device\n   *\n   * - format (\"legacy\" | \"p2sh\" | \"bech32\") to use different bitcoin address formatter.\n   *\n   * NB The normal usage is to use:\n   *\n   * - legacy format with 44' paths\n   *\n   * - p2sh format with 49' paths\n   *\n   * - bech32 format with 173' paths\n   *\n   * @example\n   * btc.getWalletPublicKey(\"44'/0'/0'/0/0\").then(o => o.bitcoinAddress)\n   * btc.getWalletPublicKey(\"49'/0'/0'/0/0\", { format: \"p2sh\" }).then(o => o.bitcoinAddress)\n   */\n  getWalletPublicKey(\n    path: string,\n    opts?:\n      | boolean\n      | {\n          verify?: boolean,\n          format?: AddressFormat\n        }\n  ): Promise<{\n    publicKey: string,\n    bitcoinAddress: string,\n    chainCode: string\n  }> {\n    let options;\n    if (arguments.length > 2 || typeof opts === \"boolean\") {\n      console.warn(\n        \"btc.getWalletPublicKey deprecated signature used. Please switch to getWalletPublicKey(path, { format, verify })\"\n      );\n      options = {\n        verify: !!opts,\n        format: arguments[2] ? \"p2sh\" : \"legacy\"\n      };\n    } else {\n      options = opts || {};\n    }\n    return this.getWalletPublicKey_private(path, options);\n  }\n\n  getTrustedInputRaw(\n    transactionData: Buffer,\n    indexLookup: ?number\n  ): Promise<string> {\n    let data;\n    let firstRound = false;\n    if (typeof indexLookup === \"number\") {\n      firstRound = true;\n      const prefix = Buffer.alloc(4);\n      prefix.writeUInt32BE(indexLookup, 0);\n      data = Buffer.concat(\n        [prefix, transactionData],\n        transactionData.length + 4\n      );\n    } else {\n      data = transactionData;\n    }\n    return this.transport\n      .send(0xe0, 0x42, firstRound ? 0x00 : 0x80, 0x00, data)\n      .then(trustedInput =>\n        trustedInput.slice(0, trustedInput.length - 2).toString(\"hex\")\n      );\n  }\n\n  getTrustedInput(\n    indexLookup: number,\n    transaction: Transaction,\n    additionals: Array<string> = []\n  ): Promise<string> {\n    const { inputs, outputs, locktime } = transaction;\n    if (!outputs || !locktime) {\n      throw new Error(\"getTrustedInput: locktime & outputs is expected\");\n    }\n    const isDecred = additionals.includes(\"decred\");\n    const processScriptBlocks = (script, sequence) => {\n      const scriptBlocks = [];\n      let offset = 0;\n      while (offset !== script.length) {\n        let blockSize =\n          script.length - offset > MAX_SCRIPT_BLOCK\n            ? MAX_SCRIPT_BLOCK\n            : script.length - offset;\n        if (offset + blockSize !== script.length) {\n          scriptBlocks.push(script.slice(offset, offset + blockSize));\n        } else {\n          scriptBlocks.push(\n            Buffer.concat([script.slice(offset, offset + blockSize), sequence])\n          );\n        }\n        offset += blockSize;\n      }\n\n      // Handle case when no script length: we still want to pass the sequence\n      // relatable: https://github.com/LedgerHQ/ledger-live-desktop/issues/1386\n      if (script.length === 0) {\n        scriptBlocks.push(sequence);\n      }\n\n      return eachSeries(scriptBlocks, scriptBlock =>\n        this.getTrustedInputRaw(scriptBlock)\n      );\n    };\n\n    const processWholeScriptBlock = (script, sequence) =>\n      this.getTrustedInputRaw(Buffer.concat([script, sequence]));\n\n    const processInputs = () => {\n      return eachSeries(inputs, input => {\n        const treeField = isDecred\n          ? input.tree || Buffer.from([0x00])\n          : Buffer.alloc(0);\n        const data = Buffer.concat([\n          input.prevout,\n          treeField,\n          this.createVarint(input.script.length)\n        ]);\n        return this.getTrustedInputRaw(data).then(() => {\n          // iteration (eachSeries) ended\n          // TODO notify progress\n          // deferred.notify(\"input\");\n          return isDecred\n            ? processWholeScriptBlock(input.script, input.sequence)\n            : processScriptBlocks(input.script, input.sequence);\n        });\n      }).then(() => {\n        const data = this.createVarint(outputs.length);\n        return this.getTrustedInputRaw(data);\n      });\n    };\n\n    const processOutputs = () =>\n      eachSeries(outputs, output => {\n        let data = output.amount;\n        data = Buffer.concat([\n          data,\n          isDecred ? Buffer.from([0x00, 0x00]) : Buffer.alloc(0), //Version script\n          this.createVarint(output.script.length),\n          output.script\n        ]);\n        return this.getTrustedInputRaw(data).then(() => {\n          // iteration (eachSeries) ended\n          // TODO notify progress\n          // deferred.notify(\"output\");\n        });\n      }).then(() => {\n        //Add expiry height for decred\n        const finalData = isDecred\n          ? Buffer.concat([locktime, Buffer.from([0x00, 0x00, 0x00, 0x00])])\n          : locktime;\n        return this.getTrustedInputRaw(finalData);\n      });\n\n    const data = Buffer.concat([\n      transaction.version,\n      transaction.timestamp || Buffer.alloc(0),\n      this.createVarint(inputs.length)\n    ]);\n    return this.getTrustedInputRaw(data, indexLookup)\n      .then(processInputs)\n      .then(processOutputs);\n  }\n\n  async getTrustedInputBIP143(\n    indexLookup: number,\n    transaction: Transaction,\n    additionals: Array<string> = []\n  ) {\n    if (!transaction) {\n      throw new Error(\"getTrustedInputBIP143: missing tx\");\n    }\n    const isDecred = additionals.includes(\"decred\");\n    if (isDecred) {\n      throw new Error(\"Decred does not implement BIP143\");\n    }\n    let sha = createHash(\"sha256\");\n    sha.update(this.serializeTransaction(transaction, true));\n    let hash = sha.digest();\n    sha = createHash(\"sha256\");\n    sha.update(hash);\n    hash = sha.digest();\n    const data = Buffer.alloc(4);\n    data.writeUInt32LE(indexLookup, 0);\n    const { outputs, locktime } = transaction;\n    if (!outputs || !locktime) {\n      throw new Error(\"getTrustedInputBIP143: locktime & outputs is expected\");\n    }\n    if (!outputs[indexLookup]) {\n      throw new Error(\"getTrustedInputBIP143: wrong index\");\n    }\n    hash = Buffer.concat([hash, data, outputs[indexLookup].amount]);\n    return await hash.toString(\"hex\");\n  }\n\n  getVarint(data: Buffer, offset: number): [number, number] {\n    if (data[offset] < 0xfd) {\n      return [data[offset], 1];\n    }\n    if (data[offset] === 0xfd) {\n      return [(data[offset + 2] << 8) + data[offset + 1], 3];\n    }\n    if (data[offset] === 0xfe) {\n      return [\n        (data[offset + 4] << 24) +\n          (data[offset + 3] << 16) +\n          (data[offset + 2] << 8) +\n          data[offset + 1],\n        5\n      ];\n    }\n\n    throw new Error(\"getVarint called with unexpected parameters\");\n  }\n\n  startUntrustedHashTransactionInputRaw(\n    newTransaction: boolean,\n    firstRound: boolean,\n    transactionData: Buffer,\n    bip143?: boolean = false,\n    overwinter?: boolean = false,\n    additionals: Array<string> = []\n  ) {\n    const p2 = bip143\n      ? additionals.includes(\"sapling\")\n        ? 0x05\n        : overwinter\n        ? 0x04\n        : 0x02\n      : 0x00;\n    return this.transport.send(\n      0xe0,\n      0x44,\n      firstRound ? 0x00 : 0x80,\n      newTransaction ? p2 : 0x80,\n      transactionData\n    );\n  }\n\n  startUntrustedHashTransactionInput(\n    newTransaction: boolean,\n    transaction: Transaction,\n    inputs: Array<{ trustedInput: boolean, value: Buffer }>,\n    bip143?: boolean = false,\n    overwinter?: boolean = false,\n    additionals: Array<string> = []\n  ) {\n    let data = Buffer.concat([\n      transaction.version,\n      transaction.timestamp || Buffer.alloc(0),\n      transaction.nVersionGroupId || Buffer.alloc(0),\n      this.createVarint(transaction.inputs.length)\n    ]);\n    return this.startUntrustedHashTransactionInputRaw(\n      newTransaction,\n      true,\n      data,\n      bip143,\n      overwinter,\n      additionals\n    ).then(() => {\n      let i = 0;\n      const isDecred = additionals.includes(\"decred\");\n      return eachSeries(transaction.inputs, input => {\n        let prefix;\n        if (bip143) {\n          prefix = Buffer.from([0x02]);\n        } else {\n          if (inputs[i].trustedInput) {\n            prefix = Buffer.from([0x01, inputs[i].value.length]);\n          } else {\n            prefix = Buffer.from([0x00]);\n          }\n        }\n        data = Buffer.concat([\n          prefix,\n          inputs[i].value,\n          isDecred ? Buffer.from([0x00]) : Buffer.alloc(0),\n          this.createVarint(input.script.length)\n        ]);\n        return this.startUntrustedHashTransactionInputRaw(\n          newTransaction,\n          false,\n          data,\n          bip143,\n          overwinter,\n          additionals\n        ).then(() => {\n          let scriptBlocks = [];\n          let offset = 0;\n          if (input.script.length === 0) {\n            scriptBlocks.push(input.sequence);\n          } else {\n            while (offset !== input.script.length) {\n              let blockSize =\n                input.script.length - offset > MAX_SCRIPT_BLOCK\n                  ? MAX_SCRIPT_BLOCK\n                  : input.script.length - offset;\n              if (offset + blockSize !== input.script.length) {\n                scriptBlocks.push(\n                  input.script.slice(offset, offset + blockSize)\n                );\n              } else {\n                scriptBlocks.push(\n                  Buffer.concat([\n                    input.script.slice(offset, offset + blockSize),\n                    input.sequence\n                  ])\n                );\n              }\n              offset += blockSize;\n            }\n          }\n          return eachSeries(scriptBlocks, scriptBlock => {\n            return this.startUntrustedHashTransactionInputRaw(\n              newTransaction,\n              false,\n              scriptBlock,\n              bip143,\n              overwinter,\n              additionals\n            );\n          }).then(() => {\n            i++;\n          });\n        });\n      });\n    });\n  }\n\n  provideOutputFullChangePath(path: string): Promise<string> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xe0, 0x4a, 0xff, 0x00, buffer);\n  }\n\n  hashOutputFull(\n    outputScript: Buffer,\n    additionals: Array<string> = []\n  ): Promise<*> {\n    let offset = 0;\n    let p1 = 0x80;\n    const isDecred = additionals.includes(\"decred\");\n    ///WARNING: Decred works only with one call (without chunking)\n    //TODO: test without this for Decred\n    if (isDecred) {\n      return this.transport.send(0xe0, 0x4a, p1, 0x00, outputScript);\n    }\n    return asyncWhile(\n      () => offset < outputScript.length,\n      () => {\n        let blockSize =\n          offset + MAX_SCRIPT_BLOCK >= outputScript.length\n            ? outputScript.length - offset\n            : MAX_SCRIPT_BLOCK;\n        let p1 = offset + blockSize === outputScript.length ? 0x80 : 0x00;\n        let data = outputScript.slice(offset, offset + blockSize);\n\n        return this.transport.send(0xe0, 0x4a, p1, 0x00, data).then(() => {\n          offset += blockSize;\n        });\n      }\n    );\n  }\n\n  signTransaction(\n    path: string,\n    lockTime?: number = DEFAULT_LOCKTIME,\n    sigHashType?: number = SIGHASH_ALL,\n    expiryHeight?: Buffer,\n    additionals: Array<string> = []\n  ): Promise<Buffer> {\n    const isDecred = additionals.includes(\"decred\");\n    const paths = splitPath(path);\n    let offset = 0;\n    const pathsBuffer = Buffer.alloc(paths.length * 4);\n    paths.forEach(element => {\n      pathsBuffer.writeUInt32BE(element, offset);\n      offset += 4;\n    });\n    const lockTimeBuffer = Buffer.alloc(4);\n    lockTimeBuffer.writeUInt32BE(lockTime, 0);\n    let buffer = isDecred\n      ? Buffer.concat([\n          Buffer.from([paths.length]),\n          pathsBuffer,\n          lockTimeBuffer,\n          expiryHeight || Buffer.from([0x00, 0x00, 0x00, 0x00]),\n          Buffer.from([sigHashType])\n        ])\n      : Buffer.concat([\n          Buffer.from([paths.length]),\n          pathsBuffer,\n          Buffer.from([0x00]),\n          lockTimeBuffer,\n          Buffer.from([sigHashType])\n        ]);\n    if (expiryHeight && !isDecred) {\n      buffer = Buffer.concat([buffer, expiryHeight]);\n    }\n    return this.transport.send(0xe0, 0x48, 0x00, 0x00, buffer).then(result => {\n      if (result.length > 0) {\n        result[0] = 0x30;\n        return result.slice(0, result.length - 2);\n      }\n      return result;\n    });\n  }\n\n  /**\n   * You can sign a message according to the Bitcoin Signature format and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n   * @example\n   btc.signMessageNew_async(\"44'/60'/0'/0'/0\", Buffer.from(\"test\").toString(\"hex\")).then(function(result) {\n     var v = result['v'] + 27 + 4;\n     var signature = Buffer.from(v.toString(16) + result['r'] + result['s'], 'hex').toString('base64');\n     console.log(\"Signature : \" + signature);\n   }).catch(function(ex) {console.log(ex);});\n   */\n  signMessageNew(\n    path: string,\n    messageHex: string\n  ): Promise<{ v: number, r: string, s: string }> {\n    const paths = splitPath(path);\n    const message = new Buffer(messageHex, \"hex\");\n    let offset = 0;\n    const toSend = [];\n    while (offset !== message.length) {\n      let maxChunkSize =\n        offset === 0\n          ? MAX_SCRIPT_BLOCK - 1 - paths.length * 4 - 4\n          : MAX_SCRIPT_BLOCK;\n      let chunkSize =\n        offset + maxChunkSize > message.length\n          ? message.length - offset\n          : maxChunkSize;\n      const buffer = new Buffer(\n        offset === 0 ? 1 + paths.length * 4 + 2 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt16BE(message.length, 1 + 4 * paths.length);\n        message.copy(\n          buffer,\n          1 + 4 * paths.length + 2,\n          offset,\n          offset + chunkSize\n        );\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport.send(0xe0, 0x4e, 0x00, i === 0 ? 0x01 : 0x80, data)\n    ).then(() => {\n      return this.transport\n        .send(0xe0, 0x4e, 0x80, 0x00, Buffer.from([0x00]))\n        .then(response => {\n          const v = response[0] - 0x30;\n          let r = response.slice(4, 4 + response[3]);\n          if (r[0] === 0) {\n            r = r.slice(1);\n          }\n          r = r.toString(\"hex\");\n          let offset = 4 + response[3] + 2;\n          let s = response.slice(offset, offset + response[offset - 1]);\n          if (s[0] === 0) {\n            s = s.slice(1);\n          }\n          s = s.toString(\"hex\");\n          return { v, r, s };\n        });\n    });\n  }\n\n  /**\n   * To sign a transaction involving standard (P2PKH) inputs, call createPaymentTransactionNew with the following parameters\n   * @param inputs is an array of [ transaction, output_index, optional redeem script, optional sequence ] where\n   *\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the optional redeem script to use when consuming a Segregated Witness input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param changePath is an optional BIP 32 path pointing to the path to the public key used to compute the change address\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @param segwit is an optional boolean indicating wether to use segwit or not\n   * @param initialTimestamp is an optional timestamp of the function call to use for coins that necessitate timestamps only, (not the one that the tx will include)\n   * @param additionals list of additionnal options\n   * - \"abc\" for bch\n   * - \"gold\" for btg\n   * - \"bipxxx\" for using BIPxxx\n   * - \"sapling\" to indicate a zec transaction is supporting sapling (to be set over block 419200)\n   * @param expiryHeight is an optional Buffer for zec overwinter / sapling Txs\n   * @return the signed transaction ready to be broadcast\n   * @example\nbtc.createPaymentTransactionNew(\n   [ [tx1, 1] ],\n   [\"0'/0/0\"],\n   undefined,\n   \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n ).then(res => ...);\n   */\n  createPaymentTransactionNew(\n    inputs: Array<[Transaction, number, ?string, ?number]>,\n    associatedKeysets: string[],\n    changePath?: string,\n    outputScriptHex: string,\n    lockTime?: number = DEFAULT_LOCKTIME,\n    sigHashType?: number = SIGHASH_ALL,\n    segwit?: boolean = false,\n    initialTimestamp?: number,\n    additionals: Array<string> = [],\n    expiryHeight?: Buffer\n  ) {\n    const isDecred = additionals.includes(\"decred\");\n    const hasTimestamp = initialTimestamp !== undefined;\n    let startTime = Date.now();\n    const sapling = additionals.includes(\"sapling\");\n    let useBip143 =\n      segwit ||\n      (!!additionals &&\n        (additionals.includes(\"abc\") ||\n          additionals.includes(\"gold\") ||\n          additionals.includes(\"bip143\"))) ||\n      (!!expiryHeight && !isDecred);\n    // Inputs are provided as arrays of [transaction, output_index, optional redeem script, optional sequence]\n    // associatedKeysets are provided as arrays of [path]\n    const nullScript = Buffer.alloc(0);\n    const nullPrevout = Buffer.alloc(0);\n    const defaultVersion = Buffer.alloc(4);\n    !!expiryHeight && !isDecred\n      ? defaultVersion.writeUInt32LE(sapling ? 0x80000004 : 0x80000003, 0)\n      : defaultVersion.writeUInt32LE(1, 0);\n    const trustedInputs: Array<*> = [];\n    const regularOutputs: Array<TransactionOutput> = [];\n    const signatures = [];\n    const publicKeys = [];\n    let firstRun = true;\n    const resuming = false;\n    const targetTransaction: Transaction = {\n      inputs: [],\n      version: defaultVersion,\n      timestamp: Buffer.alloc(0)\n    };\n    const getTrustedInputCall = useBip143\n      ? this.getTrustedInputBIP143.bind(this)\n      : this.getTrustedInput.bind(this);\n    const outputScript = Buffer.from(outputScriptHex, \"hex\");\n\n    return foreach(inputs, input => {\n      return doIf(!resuming, () => {\n        return getTrustedInputCall(input[1], input[0], additionals).then(\n          trustedInput => {\n            let sequence = Buffer.alloc(4);\n            sequence.writeUInt32LE(\n              input.length >= 4 && typeof input[3] === \"number\"\n                ? input[3]\n                : DEFAULT_SEQUENCE,\n              0\n            );\n            trustedInputs.push({\n              trustedInput: true,\n              value: Buffer.from(trustedInput, \"hex\"),\n              sequence\n            });\n          }\n        );\n      })\n        .then(() => {\n          const { outputs } = input[0];\n          const index = input[1];\n          if (outputs && index <= outputs.length - 1) {\n            regularOutputs.push(outputs[index]);\n          }\n        })\n        .then(() => {\n          if (!!expiryHeight && !isDecred) {\n            targetTransaction.nVersionGroupId = Buffer.from(\n              sapling ? [0x85, 0x20, 0x2f, 0x89] : [0x70, 0x82, 0xc4, 0x03]\n            );\n            targetTransaction.nExpiryHeight = expiryHeight;\n            // For sapling : valueBalance (8), nShieldedSpend (1), nShieldedOutput (1), nJoinSplit (1)\n            // Overwinter : use nJoinSplit (1)\n            targetTransaction.extraData = Buffer.from(\n              sapling\n                ? [\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00\n                  ]\n                : [0x00]\n            );\n          } else if (isDecred) {\n            targetTransaction.nExpiryHeight = expiryHeight;\n          }\n        });\n    })\n      .then(() => {\n        for (let i = 0; i < inputs.length; i++) {\n          let sequence = Buffer.alloc(4);\n          sequence.writeUInt32LE(\n            inputs[i].length >= 4 && typeof inputs[i][3] === \"number\"\n              ? inputs[i][3]\n              : DEFAULT_SEQUENCE,\n            0\n          );\n          targetTransaction.inputs.push({\n            script: nullScript,\n            prevout: nullPrevout,\n            sequence\n          });\n        }\n      })\n      .then(() =>\n        doIf(!resuming, () =>\n          // Collect public keys\n          foreach(inputs, (input, i) =>\n            this.getWalletPublicKey_private(associatedKeysets[i])\n          ).then(result => {\n            for (let index = 0; index < result.length; index++) {\n              publicKeys.push(\n                this.compressPublicKey(\n                  Buffer.from(result[index].publicKey, \"hex\")\n                )\n              );\n            }\n          })\n        )\n      )\n      .then(() => {\n        if (hasTimestamp) {\n          targetTransaction.timestamp = Buffer.alloc(4);\n          targetTransaction.timestamp.writeUInt32LE(\n            Math.floor(initialTimestamp + (Date.now() - startTime) / 1000),\n            0\n          );\n        }\n      })\n      .then(() =>\n        doIf(useBip143, () =>\n          // Do the first run with all inputs\n          this.startUntrustedHashTransactionInput(\n            true,\n            targetTransaction,\n            trustedInputs,\n            true,\n            !!expiryHeight,\n            additionals\n          ).then(() =>\n            doIf(!resuming && typeof changePath != \"undefined\", () => {\n              // $FlowFixMe\n              return this.provideOutputFullChangePath(changePath);\n            }).then(() => this.hashOutputFull(outputScript))\n          )\n        )\n      )\n      .then(() =>\n        doIf(!!expiryHeight && !isDecred, () =>\n          // FIXME: I think we should always pass lockTime here.\n          this.signTransaction(\"\", lockTime, SIGHASH_ALL, expiryHeight)\n        )\n      )\n      .then(() =>\n        // Do the second run with the individual transaction\n        foreach(inputs, (input, i) => {\n          let script =\n            inputs[i].length >= 3 && typeof inputs[i][2] === \"string\"\n              ? Buffer.from(inputs[i][2], \"hex\")\n              : !segwit\n              ? regularOutputs[i].script\n              : Buffer.concat([\n                  Buffer.from([OP_DUP, OP_HASH160, HASH_SIZE]),\n                  this.hashPublicKey(publicKeys[i]),\n                  Buffer.from([OP_EQUALVERIFY, OP_CHECKSIG])\n                ]);\n          let pseudoTX = Object.assign({}, targetTransaction);\n          let pseudoTrustedInputs = useBip143\n            ? [trustedInputs[i]]\n            : trustedInputs;\n          if (useBip143) {\n            pseudoTX.inputs = [{ ...pseudoTX.inputs[i], script }];\n          } else {\n            pseudoTX.inputs[i].script = script;\n          }\n          return this.startUntrustedHashTransactionInput(\n            !useBip143 && firstRun,\n            pseudoTX,\n            pseudoTrustedInputs,\n            useBip143,\n            !!expiryHeight && !isDecred,\n            additionals\n          )\n            .then(() =>\n              doIf(!useBip143, () =>\n                doIf(!resuming && typeof changePath != \"undefined\", () => {\n                  // $FlowFixMe\n                  return this.provideOutputFullChangePath(changePath);\n                }).then(() => this.hashOutputFull(outputScript, additionals))\n              )\n            )\n            .then(() => {\n              return this.signTransaction(\n                associatedKeysets[i],\n                lockTime,\n                sigHashType,\n                expiryHeight,\n                additionals\n              );\n            })\n            .then(signature => {\n              signatures.push(signature);\n              targetTransaction.inputs[i].script = nullScript;\n              if (firstRun) {\n                firstRun = false;\n              }\n            });\n        })\n      )\n      .then(() => {\n        // Populate the final input scripts\n        for (let i = 0; i < inputs.length; i++) {\n          if (segwit) {\n            targetTransaction.witness = Buffer.alloc(0);\n            targetTransaction.inputs[i].script = Buffer.concat([\n              Buffer.from(\"160014\", \"hex\"),\n              this.hashPublicKey(publicKeys[i])\n            ]);\n          } else {\n            const signatureSize = Buffer.alloc(1);\n            const keySize = Buffer.alloc(1);\n            signatureSize[0] = signatures[i].length;\n            keySize[0] = publicKeys[i].length;\n            targetTransaction.inputs[i].script = Buffer.concat([\n              signatureSize,\n              signatures[i],\n              keySize,\n              publicKeys[i]\n            ]);\n          }\n          let offset = useBip143 ? 0 : 4;\n          targetTransaction.inputs[i].prevout = trustedInputs[i].value.slice(\n            offset,\n            offset + 0x24\n          );\n        }\n\n        const lockTimeBuffer = Buffer.alloc(4);\n        lockTimeBuffer.writeUInt32LE(lockTime, 0);\n\n        var result = Buffer.concat([\n          this.serializeTransaction(\n            targetTransaction,\n            false,\n            targetTransaction.timestamp,\n            additionals\n          ),\n          outputScript\n        ]);\n\n        if (segwit && !isDecred) {\n          var witness = Buffer.alloc(0);\n          for (var i = 0; i < inputs.length; i++) {\n            var tmpScriptData = Buffer.concat([\n              Buffer.from(\"02\", \"hex\"),\n              Buffer.from([signatures[i].length]),\n              signatures[i],\n              Buffer.from([publicKeys[i].length]),\n              publicKeys[i]\n            ]);\n            witness = Buffer.concat([witness, tmpScriptData]);\n          }\n          result = Buffer.concat([result, witness]);\n        }\n\n        // FIXME: In ZEC or KMD sapling lockTime is serialized before expiryHeight.\n        // expiryHeight is used only in overwinter/sapling so I moved lockTimeBuffer here\n        // and it should not break other coins because expiryHeight is false for them.\n        // Don't know about Decred though.\n        result = Buffer.concat([result, lockTimeBuffer]);\n\n        if (expiryHeight) {\n          result = Buffer.concat([\n            result,\n            targetTransaction.nExpiryHeight || Buffer.alloc(0),\n            targetTransaction.extraData || Buffer.alloc(0)\n          ]);\n        }\n\n        if (isDecred) {\n          let decredWitness = Buffer.from([targetTransaction.inputs.length]);\n          inputs.forEach((input, inputIndex) => {\n            decredWitness = Buffer.concat([\n              decredWitness,\n              Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),\n              Buffer.from([0x00, 0x00, 0x00, 0x00]), //Block height\n              Buffer.from([0xff, 0xff, 0xff, 0xff]), //Block index\n              Buffer.from([targetTransaction.inputs[inputIndex].script.length]),\n              targetTransaction.inputs[inputIndex].script\n            ]);\n          });\n\n          result = Buffer.concat([result, decredWitness]);\n        }\n\n        return result.toString(\"hex\");\n      });\n  }\n\n  /**\n   * To obtain the signature of multisignature (P2SH) inputs, call signP2SHTransaction_async with the folowing parameters\n   * @param inputs is an array of [ transaction, output_index, redeem script, optional sequence ] where\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the mandatory redeem script associated to the current P2SH input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @return the signed transaction ready to be broadcast\n   * @example\nbtc.signP2SHTransaction(\n [ [tx, 1, \"52210289b4a3ad52a919abd2bdd6920d8a6879b1e788c38aa76f0440a6f32a9f1996d02103a3393b1439d1693b063482c04bd40142db97bdf139eedd1b51ffb7070a37eac321030b9a409a1e476b0d5d17b804fcdb81cf30f9b99c6f3ae1178206e08bc500639853ae\"] ],\n [\"0'/0/0\"],\n \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n).then(result => ...);\n   */\n  signP2SHTransaction(\n    inputs: Array<[Transaction, number, ?string, ?number]>,\n    associatedKeysets: string[],\n    outputScriptHex: string,\n    lockTime?: number = DEFAULT_LOCKTIME,\n    sigHashType?: number = SIGHASH_ALL,\n    segwit?: boolean = false,\n    transactionVersion?: number = DEFAULT_VERSION\n  ) {\n    // Inputs are provided as arrays of [transaction, output_index, redeem script, optional sequence]\n    // associatedKeysets are provided as arrays of [path]\n    const nullScript = Buffer.alloc(0);\n    const nullPrevout = Buffer.alloc(0);\n    const defaultVersion = Buffer.alloc(4);\n    defaultVersion.writeUInt32LE(transactionVersion, 0);\n    const trustedInputs = [];\n    const regularOutputs: Array<TransactionOutput> = [];\n    const signatures = [];\n    let firstRun = true;\n    const resuming = false;\n    let targetTransaction: Transaction = {\n      inputs: [],\n      version: defaultVersion\n    };\n\n    const getTrustedInputCall = segwit\n      ? this.getTrustedInputBIP143.bind(this)\n      : this.getTrustedInput.bind(this);\n    const outputScript = Buffer.from(outputScriptHex, \"hex\");\n\n    return foreach(inputs, input =>\n      doIf(!resuming, () =>\n        getTrustedInputCall(input[1], input[0]).then(trustedInput => {\n          let sequence = Buffer.alloc(4);\n          sequence.writeUInt32LE(\n            input.length >= 4 && typeof input[3] === \"number\"\n              ? input[3]\n              : DEFAULT_SEQUENCE,\n            0\n          );\n          trustedInputs.push({\n            trustedInput: false,\n            value: segwit\n              ? Buffer.from(trustedInput, \"hex\")\n              : Buffer.from(trustedInput, \"hex\").slice(4, 4 + 0x24),\n            sequence\n          });\n        })\n      ).then(() => {\n        const { outputs } = input[0];\n        const index = input[1];\n        if (outputs && index <= outputs.length - 1) {\n          regularOutputs.push(outputs[index]);\n        }\n      })\n    )\n      .then(() => {\n        // Pre-build the target transaction\n        for (let i = 0; i < inputs.length; i++) {\n          let sequence = Buffer.alloc(4);\n          sequence.writeUInt32LE(\n            inputs[i].length >= 4 && typeof inputs[i][3] === \"number\"\n              ? inputs[i][3]\n              : DEFAULT_SEQUENCE,\n            0\n          );\n          targetTransaction.inputs.push({\n            script: nullScript,\n            prevout: nullPrevout,\n            sequence\n          });\n        }\n      })\n      .then(() =>\n        doIf(segwit, () =>\n          // Do the first run with all inputs\n          this.startUntrustedHashTransactionInput(\n            true,\n            targetTransaction,\n            trustedInputs,\n            true\n          ).then(() => this.hashOutputFull(outputScript))\n        )\n      )\n      .then(() =>\n        foreach(inputs, (input, i) => {\n          let script =\n            inputs[i].length >= 3 && typeof inputs[i][2] === \"string\"\n              ? Buffer.from(inputs[i][2], \"hex\")\n              : regularOutputs[i].script;\n          let pseudoTX = Object.assign({}, targetTransaction);\n          let pseudoTrustedInputs = segwit ? [trustedInputs[i]] : trustedInputs;\n          if (segwit) {\n            pseudoTX.inputs = [{ ...pseudoTX.inputs[i], script }];\n          } else {\n            pseudoTX.inputs[i].script = script;\n          }\n          return this.startUntrustedHashTransactionInput(\n            !segwit && firstRun,\n            pseudoTX,\n            pseudoTrustedInputs,\n            segwit\n          )\n            .then(() => doIf(!segwit, () => this.hashOutputFull(outputScript)))\n            .then(() =>\n              this.signTransaction(\n                associatedKeysets[i],\n                lockTime,\n                sigHashType\n              ).then(signature => {\n                signatures.push(\n                  segwit\n                    ? signature.toString(\"hex\")\n                    : signature.slice(0, signature.length - 1).toString(\"hex\")\n                );\n                targetTransaction.inputs[i].script = nullScript;\n                if (firstRun) {\n                  firstRun = false;\n                }\n              })\n            );\n        })\n      )\n      .then(() => signatures);\n  }\n\n  compressPublicKey(publicKey: Buffer): Buffer {\n    const prefix = (publicKey[64] & 1) !== 0 ? 0x03 : 0x02;\n    const prefixBuffer = Buffer.alloc(1);\n    prefixBuffer[0] = prefix;\n    return Buffer.concat([prefixBuffer, publicKey.slice(1, 1 + 32)]);\n  }\n\n  createVarint(value: number): Buffer {\n    if (value < 0xfd) {\n      const buffer = Buffer.alloc(1);\n      buffer[0] = value;\n      return buffer;\n    }\n    if (value <= 0xffff) {\n      const buffer = Buffer.alloc(3);\n      buffer[0] = 0xfd;\n      buffer[1] = value & 0xff;\n      buffer[2] = (value >> 8) & 0xff;\n      return buffer;\n    }\n    const buffer = Buffer.alloc(5);\n    buffer[0] = 0xfe;\n    buffer[1] = value & 0xff;\n    buffer[2] = (value >> 8) & 0xff;\n    buffer[3] = (value >> 16) & 0xff;\n    buffer[4] = (value >> 24) & 0xff;\n    return buffer;\n  }\n\n  /**\n   * For each UTXO included in your transaction, create a transaction object from the raw serialized version of the transaction used in this UTXO.\n   * @example\nconst tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\n   */\n  splitTransaction(\n    transactionHex: string,\n    isSegwitSupported: ?boolean = false,\n    hasTimestamp?: boolean = false,\n    hasExtraData?: boolean = false,\n    additionals: Array<string> = []\n  ): Transaction {\n    const inputs = [];\n    const outputs = [];\n    var witness = false;\n    let offset = 0;\n    let timestamp = Buffer.alloc(0);\n    let nExpiryHeight = Buffer.alloc(0);\n    let nVersionGroupId = Buffer.alloc(0);\n    let extraData = Buffer.alloc(0);\n    const isDecred = additionals.includes(\"decred\");\n    const transaction = Buffer.from(transactionHex, \"hex\");\n    const version = transaction.slice(offset, offset + 4);\n    const overwinter =\n      version.equals(Buffer.from([0x03, 0x00, 0x00, 0x80])) ||\n      version.equals(Buffer.from([0x04, 0x00, 0x00, 0x80]));\n    offset += 4;\n    if (\n      !hasTimestamp &&\n      isSegwitSupported &&\n      (transaction[offset] === 0 && transaction[offset + 1] !== 0)\n    ) {\n      offset += 2;\n      witness = true;\n    }\n    if (hasTimestamp) {\n      timestamp = transaction.slice(offset, 4 + offset);\n      offset += 4;\n    }\n    if (overwinter) {\n      nVersionGroupId = transaction.slice(offset, 4 + offset);\n      offset += 4;\n    }\n    let varint = this.getVarint(transaction, offset);\n    const numberInputs = varint[0];\n    offset += varint[1];\n    for (let i = 0; i < numberInputs; i++) {\n      const prevout = transaction.slice(offset, offset + 36);\n      offset += 36;\n      let script = Buffer.alloc(0);\n      let tree = Buffer.alloc(0);\n      //No script for decred, it has a witness\n      if (!isDecred) {\n        varint = this.getVarint(transaction, offset);\n        offset += varint[1];\n        script = transaction.slice(offset, offset + varint[0]);\n        offset += varint[0];\n      } else {\n        //Tree field\n        tree = transaction.slice(offset, offset + 1);\n        offset += 1;\n      }\n\n      const sequence = transaction.slice(offset, offset + 4);\n      offset += 4;\n      inputs.push({ prevout, script, sequence, tree });\n    }\n    varint = this.getVarint(transaction, offset);\n    const numberOutputs = varint[0];\n    offset += varint[1];\n    for (let i = 0; i < numberOutputs; i++) {\n      const amount = transaction.slice(offset, offset + 8);\n      offset += 8;\n\n      if (isDecred) {\n        //Script version\n        offset += 2;\n      }\n\n      varint = this.getVarint(transaction, offset);\n      offset += varint[1];\n      const script = transaction.slice(offset, offset + varint[0]);\n      offset += varint[0];\n      outputs.push({ amount, script });\n    }\n    let witnessScript, locktime;\n    if (witness) {\n      witnessScript = transaction.slice(offset, -4);\n      locktime = transaction.slice(transaction.length - 4);\n    } else {\n      locktime = transaction.slice(offset, offset + 4);\n    }\n    offset += 4;\n    if (overwinter || isDecred) {\n      nExpiryHeight = transaction.slice(offset, offset + 4);\n      offset += 4;\n    }\n    if (hasExtraData) {\n      extraData = transaction.slice(offset);\n    }\n\n    //Get witnesses for Decred\n    if (isDecred) {\n      varint = this.getVarint(transaction, offset);\n      offset += varint[1];\n      if (varint[0] !== numberInputs) {\n        throw new Error(\"splitTransaction: incoherent number of witnesses\");\n      }\n      for (let i = 0; i < numberInputs; i++) {\n        //amount\n        offset += 8;\n        //block height\n        offset += 4;\n        //block index\n        offset += 4;\n        //Script size\n        varint = this.getVarint(transaction, offset);\n        offset += varint[1];\n        const script = transaction.slice(offset, offset + varint[0]);\n        offset += varint[0];\n        inputs[i].script = script;\n      }\n    }\n\n    return {\n      version,\n      inputs,\n      outputs,\n      locktime,\n      witness: witnessScript,\n      timestamp,\n      nVersionGroupId,\n      nExpiryHeight,\n      extraData\n    };\n  }\n\n  /**\n  @example\nconst tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\nconst outputScript = btc.serializeTransactionOutputs(tx1).toString('hex');\n  */\n  serializeTransactionOutputs({ outputs }: Transaction): Buffer {\n    let outputBuffer = Buffer.alloc(0);\n    if (typeof outputs !== \"undefined\") {\n      outputBuffer = Buffer.concat([\n        outputBuffer,\n        this.createVarint(outputs.length)\n      ]);\n      outputs.forEach(output => {\n        outputBuffer = Buffer.concat([\n          outputBuffer,\n          output.amount,\n          this.createVarint(output.script.length),\n          output.script\n        ]);\n      });\n    }\n    return outputBuffer;\n  }\n\n  /**\n   */\n  serializeTransaction(\n    transaction: Transaction,\n    skipWitness: boolean,\n    timestamp?: Buffer,\n    additionals: Array<string> = []\n  ) {\n    const isDecred = additionals.includes(\"decred\");\n    let inputBuffer = Buffer.alloc(0);\n    let useWitness =\n      typeof transaction[\"witness\"] != \"undefined\" && !skipWitness;\n    transaction.inputs.forEach(input => {\n      inputBuffer = isDecred\n        ? Buffer.concat([\n            inputBuffer,\n            input.prevout,\n            Buffer.from([0x00]), //tree\n            input.sequence\n          ])\n        : Buffer.concat([\n            inputBuffer,\n            input.prevout,\n            this.createVarint(input.script.length),\n            input.script,\n            input.sequence\n          ]);\n    });\n\n    let outputBuffer = this.serializeTransactionOutputs(transaction);\n    if (\n      typeof transaction.outputs !== \"undefined\" &&\n      typeof transaction.locktime !== \"undefined\"\n    ) {\n      outputBuffer = Buffer.concat([\n        outputBuffer,\n        (useWitness && transaction.witness) || Buffer.alloc(0),\n        transaction.locktime,\n        transaction.nExpiryHeight || Buffer.alloc(0),\n        transaction.extraData || Buffer.alloc(0)\n      ]);\n    }\n\n    return Buffer.concat([\n      transaction.version,\n      timestamp ? timestamp : Buffer.alloc(0),\n      transaction.nVersionGroupId || Buffer.alloc(0),\n      useWitness ? Buffer.from(\"0001\", \"hex\") : Buffer.alloc(0),\n      this.createVarint(transaction.inputs.length),\n      inputBuffer,\n      outputBuffer\n    ]);\n  }\n\n  /**\n   */\n  displayTransactionDebug(transaction: Transaction) {\n    console.log(\"version \" + transaction.version.toString(\"hex\"));\n    transaction.inputs.forEach((input, i) => {\n      const prevout = input.prevout.toString(\"hex\");\n      const script = input.script.toString(\"hex\");\n      const sequence = input.sequence.toString(\"hex\");\n      console.log(\n        `input ${i} prevout ${prevout} script ${script} sequence ${sequence}`\n      );\n    });\n    (transaction.outputs || []).forEach((output, i) => {\n      const amount = output.amount.toString(\"hex\");\n      const script = output.script.toString(\"hex\");\n      console.log(`output ${i} amount ${amount} script ${script}`);\n    });\n    if (typeof transaction.locktime !== \"undefined\") {\n      console.log(\"locktime \" + transaction.locktime.toString(\"hex\"));\n    }\n  }\n}\n\n/**\n */\ntype TransactionInput = {\n  prevout: Buffer,\n  script: Buffer,\n  sequence: Buffer,\n  tree?: Buffer\n};\n\n/**\n */\ntype TransactionOutput = {\n  amount: Buffer,\n  script: Buffer\n};\n\n/**\n */\ntype Transaction = {\n  version: Buffer,\n  inputs: TransactionInput[],\n  outputs?: TransactionOutput[],\n  locktime?: Buffer,\n  witness?: Buffer,\n  timestamp?: Buffer,\n  nVersionGroupId?: Buffer,\n  nExpiryHeight?: Buffer,\n  extraData?: Buffer\n};\n"]}